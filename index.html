<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auto Prediction with Drag</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
}
iframe {
    width: 100%;
    height: 100%;
    border: none;
}
#draggableOutput {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 1.5em;
    font-weight: bold;
    background: transparent;
    padding: 0;
    margin: 0;
    z-index: 9999;
    user-select: none;
    cursor: move;
    touch-action: none;
}
</style>
</head>
<body>

<iframe src="https://bdgab.com/#/register"></iframe>
<div id="draggableOutput">Loading...</div>

<script>
function getSize(number) {
    return (number >= 0 && number <= 4) ? "SMALL" : "BIG";
}
function getColor(number) {
    if ([2,4,6,8].includes(number)) return "Red";
    if ([1,3,7,9].includes(number)) return "Green";
    if ([0,5].includes(number)) return "Violet";
}
function calculateHiddenMarkov(sequence) {
    let transition_probs = { SMALL:{ SMALL:0, BIG:0 }, BIG:{ SMALL:0, BIG:0 } };
    let emission_probs = { SMALL:0, BIG:0 };
    let total_count = sequence.length;
    for (let i=0; i<sequence.length-1; i++) {
        let current = getSize(sequence[i]);
        let nextState = getSize(sequence[i+1]);
        transition_probs[current][nextState]++;
    }
    for (let state in transition_probs) {
        let total = Object.values(transition_probs[state]).reduce((a,b)=>a+b,0);
        if (total>0) for (let nextState in transition_probs[state]) transition_probs[state][nextState]/=total;
    }
    sequence.forEach(num => emission_probs[getSize(num)]++);
    for (let size in emission_probs) emission_probs[size]/=total_count;
    return [transition_probs, emission_probs];
}
function calculateMarkovChain(sequence) {
    let transitions = { Red:{ Red:0, Green:0, Violet:0 }, Green:{ Red:0, Green:0, Violet:0 }, Violet:{ Red:0, Green:0, Violet:0 } };
    for (let i=0; i<sequence.length-1; i++) {
        let current = getColor(sequence[i]);
        let next = getColor(sequence[i+1]);
        if (transitions[current]) transitions[current][next]++;
    }
    for (let state in transitions) {
        let total = Object.values(transitions[state]).reduce((a,b)=>a+b,0);
        if (total>0) for (let nextState in transitions[state]) transitions[state][nextState]/=total;
    }
    return transitions;
}
function predictResult(hiddenMarkov, markovChain, sequence) {
    let lastState = getSize(sequence[sequence.length-1]);
    let bigSmallProb = hiddenMarkov[0][lastState];
    let lastColor = getColor(sequence[sequence.length-1]);
    let colorProb = markovChain[lastColor];
    let bigSmallPrediction = Object.keys(bigSmallProb).reduce((a,b)=> bigSmallProb[a]>bigSmallProb[b]?a:b);
    let colorPrediction = Object.keys(colorProb).reduce((a,b)=> colorProb[a]>colorProb[b]?a:b);
    let bigSmallPercentage = hiddenMarkov[1][bigSmallPrediction]*100;
    let colorPercentage = colorProb[colorPrediction]*100;
    return bigSmallPercentage>colorPercentage ? [bigSmallPrediction,bigSmallPercentage] : [colorPrediction,colorPercentage];
}
async function fetchAndPredict() {
    try {
        let resp = await fetch('https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=' + Date.now());
        let data = await resp.json();
        let numbers = data.data.list.slice(0,5).map(item => parseInt(item.number));
        let hiddenMarkov = calculateHiddenMarkov(numbers);
        let markovChain = calculateMarkovChain(numbers);
        let [finalPrediction, finalPercentage] = predictResult(hiddenMarkov, markovChain, numbers);
        document.getElementById('draggableOutput').textContent = `âœ… ${finalPrediction} (${finalPercentage.toFixed(2)}%)`;
    } catch(e) {
        document.getElementById('draggableOutput').textContent = 'Error';
    }
}
fetchAndPredict();
setInterval(fetchAndPredict, 60000); 

const draggable = document.getElementById('draggableOutput');
let isDragging = false;
let offsetX = 0, offsetY = 0;

draggable.addEventListener('mousedown', e => {
    isDragging = true;
    offsetX = e.offsetX;
    offsetY = e.offsetY;
});
document.addEventListener('mouseup', ()=>isDragging=false);
document.addEventListener('mousemove', e => {
    if(!isDragging) return;
    draggable.style.left = (e.clientX - offsetX)+'px';
    draggable.style.top = (e.clientY - offsetY)+'px';
});
draggable.addEventListener('touchstart', e => {
    isDragging = true;
    let touch = e.touches[0];
    offsetX = touch.clientX - draggable.offsetLeft;
    offsetY = touch.clientY - draggable.offsetTop;
}, { passive: true });
document.addEventListener('touchend', ()=>isDragging=false, { passive: true });
document.addEventListener('touchmove', e => {
    if(!isDragging) return;
    let touch = e.touches[0];
    draggable.style.left = (touch.clientX - offsetX)+'px';
    draggable.style.top = (touch.clientY - offsetY)+'px';
    e.preventDefault();
}, { passive: false });
</script>

</body>
</html>